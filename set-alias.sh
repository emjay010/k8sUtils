#!/usr/bin/env bash
#
# set-alias.sh - Kubernetes & Helm Alias Management
# Version: 2.9 (Proper function ordering & full fix)
#
# Usage: source set-alias.sh [options]
# IMPORTANT: Always source this script, do NOT execute it directly.

# Prevent direct execution
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  echo "❌ Please source this script: source set-alias.sh"
  exit 1
fi

# Require Bash 4+
if [[ -z "$BASH_VERSION" || "${BASH_VERSINFO[0]}" -lt 4 ]]; then
  echo "❌ This script requires Bash 4.0+"
  return 1
fi

# Script metadata (once per shell session)
if [[ -z "${SCRIPT_INITIALIZED:-}" ]]; then
  SCRIPT_NAME="${SCRIPT_NAME:-$(basename "${BASH_SOURCE[0]}")}"
  SCRIPT_VERSION="${SCRIPT_VERSION:-2.9}"
  readonly SCRIPT_NAME SCRIPT_VERSION
  export SCRIPT_NAME SCRIPT_VERSION
  SCRIPT_INITIALIZED=1
fi

# Configuration defaults and environment variables
ALIAS_FILE="${ALIAS_FILE:-$(pwd)/.k8s_aliases}"
KUBECTL_BIN="${KUBECTL_BIN:-kubectl}"
HELM_BIN="${HELM_BIN:-helm}"
KUBE_NAMESPACE="${KUBE_NAMESPACE:-default}"
HELM_NAMESPACE="${HELM_NAMESPACE:-default}"

DRY_RUN=0
FORCE_OVERWRITE=0
QUIET_MODE=0
VERBOSE=0

# ------------------------------------
# Logging helpers
log()         { [[ $QUIET_MODE -eq 0 ]] && echo "$@"; }
log_verbose() { [[ $VERBOSE -eq 1 ]] && echo "🔍 $*"; }
log_error()   { echo "❌ $*" >&2; }
log_success() { [[ $QUIET_MODE -eq 0 ]] && echo "✅ $*"; }
log_warning() { [[ $QUIET_MODE -eq 0 ]] && echo "⚠️  $*"; }

# ------------------------------------
# Config setters
set_namespace() {
  local ns="$1"
  if [[ -z "$ns" ]]; then log_error "Namespace cannot be empty"; return 1; fi
  export KUBE_NAMESPACE="$ns" HELM_NAMESPACE="$ns"
  log_success "Both namespaces set to '$ns'"
}

set_kube_namespace() {
  local ns="$1"
  if [[ -z "$ns" ]]; then log_error "Kubernetes namespace cannot be empty"; return 1; fi
  export KUBE_NAMESPACE="$ns"
  log_success "Kubernetes namespace set to '$ns'"
}

set_helm_namespace() {
  local ns="$1"
  if [[ -z "$ns" ]]; then log_error "Helm namespace cannot be empty"; return 1; fi
  export HELM_NAMESPACE="$ns"
  log_success "Helm namespace set to '$ns'"
}

set_binaries() {
  local kb="$1" hb="$2"
  if [[ -z "$kb" || -z "$hb" ]]; then
    log_error "Both kubectl and helm binary paths required"
    return 1
  fi
  export KUBECTL_BIN="$kb" HELM_BIN="$hb"
  log_success "Kubectl: $KUBECTL_BIN, Helm: $HELM_BIN"
}

# ------------------------------------
# Alias file helpers
init_alias_file() {
  if [[ ! -f "$ALIAS_FILE" ]]; then
    log_verbose "Creating alias file at $ALIAS_FILE"
    cat > "$ALIAS_FILE" <<EOF
# Kubernetes & Helm Aliases
# Generated by $SCRIPT_NAME v$SCRIPT_VERSION on $(date)

# BEGIN DEFAULT ALIASES
# END DEFAULT ALIASES
EOF
  fi
}

atomic_write() {
  local content="$1"
  local tmp="${ALIAS_FILE}.tmp"
  echo -e "$content" > "$tmp" && mv -f "$tmp" "$ALIAS_FILE"
}

replace_block_in_file() {
  local file="$1" begin="$2" end="$3" content="$4" tmp="${file}.tmp"
  awk -v b="$begin" -v e="$end" -v c="$content" '
    $0 ~ b { print; print c; skip=1; next }
    $0 ~ e { skip=0; print; next }
    skip==0 { print }
  ' "$file" > "$tmp" && mv -f "$tmp" "$file"
}

# ------------------------------------
# Alias management helpers
alias_exists() { alias "$1" &>/dev/null; }
is_conflict_alias() { type "$1" &>/dev/null && ! alias "$1" &>/dev/null; }

# Define default aliases with dynamic namespace vars escaped for runtime
define_default_aliases() {
  log_verbose "Defining default aliases..."

  declare -A kubectl_aliases=(
    [k]="$KUBECTL_BIN"
    [kn]="$KUBECTL_BIN config set-context --current --namespace"
    [kgp]="$KUBECTL_BIN get pods -n \${KUBE_NAMESPACE:-default}"
    [kgpw]="$KUBECTL_BIN get pods -o wide -n \${KUBE_NAMESPACE:-default}"
    [kg]="$KUBECTL_BIN get -n \${KUBE_NAMESPACE:-default}"
    [kgs]="$KUBECTL_BIN get services -n \${KUBE_NAMESPACE:-default}"
    [kgd]="$KUBECTL_BIN get deployments -n \${KUBE_NAMESPACE:-default}"
    [kga]="$KUBECTL_BIN get all -n \${KUBE_NAMESPACE:-default}"
    [kgn]="$KUBECTL_BIN get namespaces"
    [kd]="$KUBECTL_BIN describe -n \${KUBE_NAMESPACE:-default}"
    [kc]="$KUBECTL_BIN create -n \${KUBE_NAMESPACE:-default}"
    [krm]="$KUBECTL_BIN delete -n \${KUBE_NAMESPACE:-default}"
    [kaf]="$KUBECTL_BIN apply -f"
    [kdf]="$KUBECTL_BIN delete -f"
    [kpf]="$KUBECTL_BIN port-forward -n \${KUBE_NAMESPACE:-default}"
    [kl]="$KUBECTL_BIN logs -n \${KUBE_NAMESPACE:-default}"
    [klf]="$KUBECTL_BIN logs -f -n \${KUBE_NAMESPACE:-default}"
    [kex]="$KUBECTL_BIN exec -it -n \${KUBE_NAMESPACE:-default}"
    [kedit]="$KUBECTL_BIN edit -n \${KUBE_NAMESPACE:-default}"
    [kcp]="$KUBECTL_BIN cp -n \${KUBE_NAMESPACE:-default}"
    [ktop]="$KUBECTL_BIN top pods -n \${KUBE_NAMESPACE:-default}"
    [ktopn]="$KUBECTL_BIN top nodes"
    [kw]="$KUBECTL_BIN get pods -w -n \${KUBE_NAMESPACE:-default}"
    [kctx]="$KUBECTL_BIN config current-context"
    [kctxs]="$KUBECTL_BIN config get-contexts"
  )

  declare -A helm_aliases=(
    [h]="$HELM_BIN"
    [hi]="$HELM_BIN install -n \${HELM_NAMESPACE:-default}"
    [hupg]="$HELM_BIN upgrade -n \${HELM_NAMESPACE:-default}"
    [hls]="$HELM_BIN list -n \${HELM_NAMESPACE:-default}"
    [hlsa]="$HELM_BIN list --all-namespaces"
    [hrm]="$HELM_BIN uninstall -n \${HELM_NAMESPACE:-default}"
    [hrb]="$HELM_BIN rollback -n \${HELM_NAMESPACE:-default}"
    [hgv]="$HELM_BIN get values -n \${HELM_NAMESPACE:-default}"
    [hgm]="$HELM_BIN get manifest -n \${HELM_NAMESPACE:-default}"
    [hh]="$HELM_BIN history -n \${HELM_NAMESPACE:-default}"
    [hs]="$HELM_BIN status -n \${HELM_NAMESPACE:-default}"
    [hrepo]="$HELM_BIN repo list"
    [hrepou]="$HELM_BIN repo update"
    [hsearch]="$HELM_BIN search repo"
  )

  init_alias_file

  local alias_block=""
  for name in "${!kubectl_aliases[@]}"; do
    alias "$name"="${kubectl_aliases[$name]}"
    alias_block+="alias $name=\"${kubectl_aliases[$name]}\""$'\n'
  done
  for name in "${!helm_aliases[@]}"; do
    alias "$name"="${helm_aliases[$name]}"
    alias_block+="alias $name=\"${helm_aliases[$name]}\""$'\n'
  done

  replace_block_in_file "$ALIAS_FILE" "# BEGIN DEFAULT ALIASES" "# END DEFAULT ALIASES" "$alias_block"

  log_success "Initialized ${#kubectl_aliases[@]} kubectl and ${#helm_aliases[@]} helm default aliases"
  log "💡 Add 'source $ALIAS_FILE' to your shell rc for automatic loading."
}

add_custom_alias() {
  local name="$1" cmd="$2" desc="$3"
  [[ -z "$name" || -z "$cmd" ]] && { log_error "Alias name and command are required"; return 1; }
  if alias_exists "$name" && [[ $FORCE_OVERWRITE -eq 0 ]]; then
    log_warning "Alias '$name' exists. Use --force to overwrite"
    return 1
  fi
  if is_conflict_alias "$name"; then
    log_warning "Alias '$name' conflicts with commands/functions; choose unique name."
    return 1
  fi
  # Insert dynamic namespace reference with literal dollar sign escape
  if [[ "$cmd" =~ kubectl ]] && [[ ! "$cmd" =~ (-n|--namespace) ]]; then
    cmd="$cmd -n \${KUBE_NAMESPACE:-default}"
  elif [[ "$cmd" =~ helm ]] && [[ ! "$cmd" =~ (-n|--namespace) ]]; then
    cmd="$cmd -n \${HELM_NAMESPACE:-default}"
  fi
  if [[ $DRY_RUN -eq 1 ]]; then
    echo "DRY RUN -> alias $name=\"$cmd\""
    [[ -n "$desc" ]] && echo "    # $desc"
    return 0
  fi
  alias "$name"="$cmd"
  log_success "Alias '$name' added"
  init_alias_file
  {
    [[ -n "$desc" ]] && echo "# $desc"
    echo "alias $name=\"$cmd\""
    echo ""
  } >> "$ALIAS_FILE"
}

list_aliases() {
  ensure_aliases_initialized
  echo "📋 Current Kubernetes/Helm Aliases:"
  echo "🧭 Kubectl Namespace: $KUBE_NAMESPACE"
  echo "🧭 Helm Namespace: $HELM_NAMESPACE"
  echo "📁 Alias File: $ALIAS_FILE"
  echo ""
  local found=0
  while read -r line; do
    if [[ $line =~ ^alias\ ([kh][^=]*)= ]]; then
      echo "  $line"
      found=1
    fi
  done < <(alias | sort)
  [[ $found -eq 0 ]] && echo "  No k*/h* aliases found"
}

clear_aliases() {
  log "Clearing k*/h* aliases..."
  local count=0
  while read -r name; do
    if [[ $name =~ ^(k|h) ]]; then
      unalias "$name" 2>/dev/null && ((count++))
      log_verbose "Removed alias: $name"
    fi
  done < <(alias | sed -n 's/^alias \([^=]*\)=.*/\1/p')
  log_success "Cleared $count aliases"
}

reload_aliases() {
  if [[ ! -f "$ALIAS_FILE" ]]; then
    log_warning "Alias file not found: $ALIAS_FILE"
    log_verbose "Creating alias file and defaults..."
    define_default_aliases
    return 0
  fi
  log "Reloading aliases from $ALIAS_FILE..."
  # shellcheck disable=SC1090
  source "$ALIAS_FILE"
  log_success "Reloaded aliases"
}

print_summary() {
  ensure_aliases_initialized
  cat <<EOF
⚙️ Current Configuration
----------------------------
Script Version   : $SCRIPT_VERSION
Kubectl Binary   : $KUBECTL_BIN
Helm Binary      : $HELM_BIN
Kube Namespace   : $KUBE_NAMESPACE
Helm Namespace   : $HELM_NAMESPACE
Alias File       : $ALIAS_FILE
Force Overwrite  : $([[ $FORCE_OVERWRITE -eq 1 ]] && echo "Yes" || echo "No")
Verbose Mode     : $([[ $VERBOSE -eq 1 ]] && echo "Yes" || echo "No")
EOF
}

ensure_aliases_initialized() {
  if ! alias | grep -qE '^alias [kh]'; then
    log_verbose "No k*/h* aliases found; initializing defaults"
    define_default_aliases
  fi
}

main() {
  local operation=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -n)
        [[ -z "$2" ]] && { log_error "Namespace required after -n"; return 1; }
        set_namespace "$2"
        operation="namespace_set"
        shift 2
        ;;
      -k)
        [[ -z "$2" ]] && { log_error "Kube namespace required after -k"; return 1; }
        set_kube_namespace "$2"
        operation="namespace_set"
        shift 2
        ;;
      -H)
        [[ -z "$2" ]] && { log_error "Helm namespace required after -H"; return 1; }
        set_helm_namespace "$2"
        operation="namespace_set"
        shift 2
        ;;
      -b)
        [[ -z "$2" || -z "$3" ]] && { log_error "Kubectl and helm binaries required for -b"; return 1; }
        set_binaries "$2" "$3"
        operation="binaries_set"
        shift 3
        ;;
      -a)
        if [[ -z "$2" || -z "$3" ]]; then
          log_error "Alias name and command required for -a"
          return 1
        fi
        ensure_aliases_initialized
        add_custom_alias "$2" "$3" "$4"
        operation="alias_added"
        if [[ -n "$4" ]]; then shift 4; else shift 3; fi
        ;;
      -f)
        [[ -z "$2" ]] && { log_error "Alias file path argument required for -f"; return 1; }
        ALIAS_FILE="$2"
        shift 2
        ;;
      -l)
        list_aliases
        return 0
        ;;
      -s)
        print_summary
        return 0
        ;;
      -r)
        reload_aliases
        return 0
        ;;
      -c)
        clear_aliases
        return 0
        ;;
      --force)
        FORCE_OVERWRITE=1
        shift
        ;;
      --dry-run)
        DRY_RUN=1
        shift
        ;;
      --quiet|-q)
        QUIET_MODE=1
        shift
        ;;
      -v)
        VERBOSE=1
        shift
        ;;
      -h|--help)
        print_usage
        return 0
        ;;
      *)
        log_error "Unknown option: $1"
        print_usage
        return 1
        ;;
    esac
  done

  # Regenerate and reload if binaries or namespaces changed
  if [[ "$operation" == "namespace_set" || "$operation" == "binaries_set" ]]; then
    define_default_aliases
    reload_aliases
  elif [[ -z "$operation" ]]; then
    if [[ ! -f "$ALIAS_FILE" ]]; then
      log_verbose "Alias file missing; creating default aliases."
      define_default_aliases
    else
      ensure_aliases_initialized
    fi
  fi
}

export KUBE_NAMESPACE HELM_NAMESPACE KUBECTL_BIN HELM_BIN ALIAS_FILE

main "$@"

log "🟢 Kubernetes/Helm aliases ready! Add 'source $ALIAS_FILE' to your shell rc for persistence."

